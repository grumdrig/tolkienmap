<!DOCTYPE html>
<html>
<head>
<title>Map of Central Planet</title>
<style>
html, body {
	margin: 0;
	overflow: hidden;
}
</style>
</head>
<body>
<canvas id="map"></canvas>
<script>
// Mimicking Hand-Drawn Pencil Lines
// http://webhome.cs.uvic.ca/~blob/publications/cae08.pdf
// Hi res Middle Earth
// http://www.donsmaps.com/images29/middleearthlargelargerstill.jpg
// Middle Earth as in books, I think
// http://www.lord-of-the-rings.org/collections/maps/map6[1].jpg
// Beleriand
// https://atolkienistperspective.files.wordpress.com/2013/07/beleriand-map.jpg
Element.prototype.$ = Element.prototype.querySelector;
Element.prototype.$$ = Element.prototype.querySelectorAll;
var pow = Math.pow;
var sqrt = Math.sqrt;
var abs = Math.abs;
var min = Math.min;
var max = Math.max;
var round = Math.round;
var rand = Math.random;
function crand(scale) { return (rand() - 0.5) * scale }

var body = document.body;
var canvas = body.$("canvas#map");

var W = canvas.width  = window.innerWidth;
var H = canvas.height = window.innerHeight;

var DH = 30;
var DW = 30;

// Draw the mountains
function fieldOfMountains(ctx) {
	var peaks = [];
	for (var j = H; j > 0; j -= DH) {
	    for (var i = W; i > 0; i -= DW) {
			peaks.push({x: i - rand() * DW, y: j - rand() * DH});
		}
	}
	peaks = peaks.sort(function (a,b) { return a.y - b.y });

	[].forEach.call(peaks, function (p) {
		ctx.drawMountain(p, DW * 2, DH);
	});
}

CanvasRenderingContext2D.prototype.drawMountain = function (p, w, h, transparent) {
	this.beginPath();
	var westPt = add(p, {x:-w/2, y:h});
	var eastPt = add(p, {x: w/2, y:h});
	var westSlope = handDrawnLine(westPt, p);
	var eastSlope = handDrawnLine(p, eastPt);
	this.fillStyle = "#fff";
	if (!transparent) this.fillRect(westPt.x, westPt.y, w * 2, 20);
	this.doSpline(westSlope.concat(eastSlope));
	this.fill();
	this.stroke();

	var shadowPt = add(p, {x: -w/8 + crand(20), y:h + crand(10)});
	var shadowLine = handDrawnLine(p, shadowPt, 10);
	var bottomThereof = handDrawnLine(shadowPt, westPt);
	this.beginPath();
	this.doSpline(westSlope.concat(shadowLine).concat(bottomThereof));
	// for (var i = 1; i < westSlope.length; ++i)
	// 	doSpline(handDrawnLine(westSlope[i], eastSlope[i]));
	this.fillStyle = "#000";
	this.save();
	// this.fill();
	this.clip();
	this.crosshatchRect(p.x - w/2, p.y, w, h);
	this.restore();
}

CanvasRenderingContext2D.prototype.crosshatchRect = function (x, y, w, h) {
	// really covers more than the rect, but we'll be clipping it anyway
	this.beginPath();
	var rise = w / 2;
	for (var j = 0; j < h + rise; j += 3) {
		this.doSpline(handDrawnLine({x:x, y:y+j}, {x:x+w, y:y+j-rise}, 2));
	}
	this.stroke();
}

function mountainRange(ctx) {
	var x = ctx.canvas.width / 2;
    N = 50;
    for (var i = 0; i < N; ++i) {
      x = x + crand(100);
      y = (ctx.canvas.height - 64) * i / N + 16 * rand();
      ctx.drawMountain({x:x, y:y}, DW * 2, DH, true);
    }
  }


function bigOneInMiddle(ctx) {
	var c = scale({x:W, y:H}, 1/2);
	var s = 10;
	var m = 1.1;
	var can = document.createElement("canvas");
	can.width = m * DW * 2;
	can.height = m * DH;
	can.getContext('2d').drawMountain({x:can.width / 2, y:(1-1/m)/2}, DW * 2, DH);

	ctx.fillStyle = "#fff";
	ctx.fillRect(c.x - DW*s*m, c.y - DH*s*m/2, DW*s*m*2, DH*s*m);
	ctx.drawImage(can, c.x - DW*s*m, c.y - DH*s*m/2, DW*s*m*2, DH*s*m);
	// drawMountain(ctx, {x:c.x, y:c.y - h/2}, w, h);
}


function normalize(p)   { return scale(p, 1 / magnitude(p)) }
function magnitude(p)   { return sqrt(p.x * p.x + p.y * p.y) }
function subtract(p, q) { return {x: p.x - q.x, y: p.y - q.y} }
function add(p, q)      { return {x: p.x + q.x, y: p.y + q.y} }
function scale(p, s)    { return {x: p.x * s,   y: p.y * s} }
function copy(p)        { return {x: p.x, y: p.y} }
function average(p, q)  { return scale(add(p,q), 1/2) }
function distance(p, q) { return magnitude(subtract(p, q)) }


function handDrawnLine(p0, p1, eccentricity) {
	if (typeof eccentricity == 'undefined') eccentricity = 5;
	var diff = subtract(p0, p1);
	var dist = magnitude(diff);
	var nsegments = (dist < 200) ? 4 : (dist < 400) ? 7 : 10;
	var normal = normalize({x:p0.y-p1.y, y:p1.x-p0.x});
	var result = [copy(p0)];
	for (var i = 1; i < nsegments; ++i) {
		var t = i / nsegments;
		var h = 15 * pow(t, 4) - 6 * pow(t, 5) - 10 * pow(t, 3);
		pt = add(p0, scale(diff, h));
		result.push(add(pt, scale(normal, crand(eccentricity))));
	}
	result.push(copy(p1));
	return result;
}

function handDrawnArc(c, r, a0, a1, eccentricity) {
	if (typeof eccentricity == 'undefined') eccentricity = 5;
	var circ = abs(a1 - a0) * r;
	var nsegments = max(4, round(circ / 50));
	function point(a) { return {x:c.x + r * cos(a), y:c.y + r * sin(a)} }
	var result = [point(a0)];
	for (var i = 1; i < nsegments; ++i) {
		var t = i / nsegments;
		var pt = point(a0 + (a1 - a0) * t);
		var normal = scale(subtract(pt, c), 1/r);
		result.push(add(pt, scale(normal, crand(eccentricity))));
	}
	result.push(point(a1));
	return result;
}

CanvasRenderingContext2D.prototype.curveTo = function (ctl, end) {
	this.quadraticCurveTo(ctl.x, ctl.y, end.x, end.y)
}

CanvasRenderingContext2D.prototype.doSpline = function (ps, cont) {
	// http://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas
	if (!cont) this.moveTo(ps[0].x, ps[0].y);
	for (var i = 1; i < ps.length - 2; ++i) {
		this.curveTo(ps[i], average(ps[i], ps[i+1]));
	}
	this.curveTo(ps[ps.length - 2], ps[ps.length - 1]);
}

CanvasRenderingContext2D.prototype.drawBorder = function (inset) {
	this.beginPath();
	var r = this.canvas.width - inset;
	var b = this.canvas.height - inset;
	var tl = inset;
	var e = 2;
	this.doSpline(handDrawnLine({x:tl, y:tl}, {x:r,  y:tl}, e));
	this.doSpline(handDrawnLine({x:r, y:tl},  {x:r,  y:b}, e), true);
	this.doSpline(handDrawnLine({x:r, y:b},   {x:tl, y:b}, e), true);
	this.doSpline(handDrawnLine({x:tl, y:b},  {x:tl, y:tl}, e), true);
	this.stroke();
}

CanvasRenderingContext2D.prototype.plotPoint = function (p) {
	this.fillRect(p.x, p.y, 4, 4);
}

function averagePoints(pts) {
	var result = new Array(pts.length);
	for (var i = 0; i < pts.length; ++i) {
		result[i] = pts[i];
		for (var j = 0; j < pts.length; ++j) {
			if (i == j) continue;
			var d = distance(pts[i], pts[j]);
			result[i] = add(result[i], scale(subtract(pts[j], pts[i]), 100000/(d * d * d)));
		}
	}
	return result;
}

function minDistance(p, pts) {
	var result = Number.POSITIVE_INFINITY;
	for (var i = 0; i < pts.length; ++i) {
		var d = distance(p, pts[i]);
		if (result > d) result = d;
	}
	return result;
}

function randomMostDistantPoint(n, pts) {
	var result;
	var farness;
	for (var i = 0; i < n; ++i) {
		var c = { x: rand() * W, y: rand() * H };
		var d = minDistance(c, pts);
		if (i == 0 || farness < d) {
			farness = d;
			result = c;
		}
	}
	return result;
}

function drawMap() {
	var ctx = canvas.getContext("2d");
	ctx.clearRect(0,0,canvas.width, canvas.height);
	// fieldOfMountains(ctx);
	// bigOneInMiddle(ctx);
	ctx.lineWidth = 1;
	ctx.drawBorder(10);
	ctx.drawBorder(15);
	ctx.clip();
	mountainRange(ctx);
	mountainRange(ctx);
	mountainRange(ctx);

	var pts = [];
	for (var i = 0; i < 1000; i++) {
		pts.push(randomMostDistantPoint(1 + i/10, pts));
	}
	ctx.fillStyle = "red";
	pts.forEach(function (p) { ctx.plotPoint(p) });
	/*
	pts = averagePoints(pts);
	ctx.fillStyle = "blue";
	// pts.forEach(function (p) { ctx.plotPoint(p) });
	pts = averagePoints(pts);
	ctx.fillStyle = "green";
	pts.forEach(function (p) { ctx.plotPoint(p) });
	*/
}
canvas.addEventListener("click", drawMap);
drawMap();

</script>
</body>
</html>