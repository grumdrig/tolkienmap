<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Map of Central Planet</title>
<style>
html, body {
	margin: 0;
	overflow: hidden;
}
</style>
<script src="triangulate.js"></script>
</head>
<body>
<canvas id="map"></canvas>
<script>
"use strict";

Element.prototype.$ = Element.prototype.querySelector;
Element.prototype.$$ = Element.prototype.querySelectorAll;
var PI = Math.PI;
var pow = Math.pow;
var sqrt = Math.sqrt;
var cos = Math.cos;
var sin = Math.sin;
var abs = Math.abs;
var ceil = Math.ceil;
var min = Math.min;
var max = Math.max;
var round = Math.round;
var rand = Math.random;
function crand(scale) { return (rand() - 0.5) * scale }
function pick(a) {
	if (typeof a == 'number')
		return rand() * a >> 0;
	else
		return a[rand() * a.length >> 0];
}

var body = document.body;
var canvas = body.$("canvas#map");

var W = canvas.width  = window.innerWidth;
var H = canvas.height = window.innerHeight;

// Draw the mountains
CanvasRenderingContext2D.prototype.fieldOfMountains = function (DW, DH) {
	var ctx = this;
	var peaks = [];
	for (var j = H; j > 0; j -= DH) {
	    for (var i = W; i > 0; i -= DW) {
			peaks.push({x: i - rand() * DW, y: j - rand() * DH});
		}
	}
	peaks = peaks.sort(function (a,b) { return a.y - b.y });

	[].forEach.call(peaks, function (p) {
		ctx.mountain(p, DW * 2, DH);
	});
}

CanvasRenderingContext2D.prototype.mountain = function (p, w, h, transparent) {
	this.beginPath();
	var westPt = add(p, {x:-w/2, y:h});
	var eastPt = add(p, {x: w/2, y:h});
	var westSlope = handDrawnLine(westPt, p);
	var eastSlope = handDrawnLine(p, eastPt);
	this.fillStyle = "#fff";
	if (!transparent) this.fillRect(westPt.x, westPt.y, w * 2, 20);
	this.doSpline(westSlope.concat(eastSlope));
	this.fill();
	this.stroke();

	var shadowPt = add(p, {x: crand(w/3), y:h + crand(h/3)});
	var shadowLine = handDrawnLine(p, shadowPt, 10);
	var bottomThereof = handDrawnLine(shadowPt, westPt);
	this.beginPath();
	this.doSpline(westSlope.concat(shadowLine).concat(bottomThereof));
	// for (var i = 1; i < westSlope.length; ++i)
	// 	doSpline(handDrawnLine(westSlope[i], eastSlope[i]));
	this.fillStyle = "#000";
	this.save();
	// this.fill();
	this.clip();
	this.crosshatchRect(p.x - w/2, p.y, w, h);
	this.restore();
}

CanvasRenderingContext2D.prototype.crosshatchRect = function (x, y, w, h) {
	// really covers more than the rect, but we'll be clipping it anyway
	this.beginPath();
	var rise = w / 2;
	for (var j = 0; j < h + rise; j += 3) {
		this.doSpline(handDrawnLine({x:x, y:y+j}, {x:x+w, y:y+j-rise}, 2));
	}
	this.stroke();
}

CanvasRenderingContext2D.prototype.mountainRange = function (DW, DH) {
	var x = this.canvas.width / 2;
    let N = 50;
    for (var i = 0; i < N; ++i) {
      x = x + crand(100);
      let y = (this.canvas.height - 64) * i / N + 16 * rand();
      // console.log(y);
      this.mountain({x:x, y:y}, DW * 2, DH, true);
    }
  }


// This just shows a single mountain in the middle of the page
function bigOneInMiddle(ctx, DW, DH) {
	var c = scale({x:W, y:H}, 1/2);
	var s = 10;
	var m = 1.1;
	var can = document.createElement("canvas");
	can.width = m * DW * 2;
	can.height = m * DH;
	can.getContext('2d').mountain({x:can.width / 2, y:(1-1/m)/2}, DW * 2, DH);

	ctx.fillStyle = "#fff";
	ctx.fillRect(c.x - DW*s*m, c.y - DH*s*m/2, DW*s*m*2, DH*s*m);
	ctx.drawImage(can, c.x - DW*s*m, c.y - DH*s*m/2, DW*s*m*2, DH*s*m);
	// mountain(ctx, {x:c.x, y:c.y - h/2}, w, h);
}

function handDrawnLine(p0, p1, eccentricity) {
	if (typeof eccentricity == 'undefined') eccentricity = 5;
	var diff = subtract(p0, p1);
	var dist = magnitude(diff);
	var nsegments = (dist < 200) ? 4 : (dist < 400) ? 7 : 10;
	var normal = normalize({x:p0.y-p1.y, y:p1.x-p0.x});
	var result = [copy(p0)];
	for (var i = 1; i < nsegments; ++i) {
		var t = i / nsegments;
		var h = 15 * pow(t, 4) - 6 * pow(t, 5) - 10 * pow(t, 3);
		var pt = add(p0, scale(diff, h));
		result.push(add(pt, scale(normal, crand(eccentricity))));
	}
	result.push(copy(p1));
	return result;
}

function handDrawnArc(c, r, a0, a1, eccentricity) {
	if (typeof eccentricity == 'undefined') eccentricity = 5;
	var circ = abs(a1 - a0) * r;
	var nsegments = max(4, round(circ / 50));
	function point(a) { return {x:c.x + r * cos(a), y:c.y + r * sin(a)} }
	var result = [point(a0)];
	for (var i = 1; i < nsegments; ++i) {
		var t = i / nsegments;
		var pt = point(a0 + (a1 - a0) * t);
		var normal = scale(subtract(pt, c), 1/r);
		result.push(add(pt, scale(normal, crand(eccentricity))));
	}
	result.push(point(a1));
	return result;
}

CanvasRenderingContext2D.prototype.curveTo = function (ctl, end) {
	this.quadraticCurveTo(ctl.x, ctl.y, end.x, end.y)
}

CanvasRenderingContext2D.prototype.doSpline = function (ps, cont) {
	// http://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas
	if (!cont) this.moveTo(ps[0].x, ps[0].y);
	for (var i = 1; i < ps.length - 2; ++i) {
		this.curveTo(ps[i], average(ps[i], ps[i+1]));
	}
	this.curveTo(ps[ps.length - 2], ps[ps.length - 1]);
}

CanvasRenderingContext2D.prototype.drawBorder = function (inset) {
	this.beginPath();
	var r = this.canvas.width - inset;
	var b = this.canvas.height - inset;
	var tl = inset;
	var e = 2;
	this.doSpline(handDrawnLine({x:tl, y:tl}, {x:r,  y:tl}, e));
	this.doSpline(handDrawnLine({x:r, y:tl},  {x:r,  y:b}, e), true);
	this.doSpline(handDrawnLine({x:r, y:b},   {x:tl, y:b}, e), true);
	this.doSpline(handDrawnLine({x:tl, y:b},  {x:tl, y:tl}, e), true);
	this.stroke();
}

CanvasRenderingContext2D.prototype.plotPoint = function (p) {
	this.fillRect(p.x, p.y, 4, 4);
}

function minDistance(p, pts) {
	var result = Number.POSITIVE_INFINITY;
	for (var i = 0; i < pts.length; ++i) {
		var d = distance(p, pts[i]);
		if (result > d) result = d;
	}
	return result;
}

function p2c(r, a) { return {x: r * cos(a), y: r * sin(a)} }

CanvasRenderingContext2D.prototype.compassRose = function (cx, cy, r) {
	var N = 16;
	for (var i = 0; i < N; ++i) {
		var a0 = i * 2 * PI / N;
		var a1 = a0 + 2 * PI / N;
		var e = 2;
		var outer = handDrawnArc({x:cx, y:cy}, r, a0, a1, e);
		var inner = handDrawnArc({x:cx, y:cy}, r * 0.83, a1, a0, e);
		var con1 = handDrawnLine(outer[outer.length - 1], inner[0], e);
		var con2 = handDrawnLine(inner[inner.length - 1], outer[0], e);
		this.beginPath();
		this.doSpline(outer);
		this.doSpline(con1, true);
		this.doSpline(inner);
		this.doSpline(con2, true);
		this.fillStyle = (i & 1) ? "red" : "black";
		this.fill();
	}
	var RP = r * 1.1;
	var RS = r * 0.2;
	var ctx = this;
	function compassPoint(a) {
		var e = 1;
		var c = {x:cx, y:cy};
		var end = add(c, p2c(RP, a));
		var s1 = add(c, p2c(RS, a + PI / 4));
		var s2 = add(c, p2c(RS, a - PI / 4));
		ctx.beginPath();
		ctx.doSpline(handDrawnLine(c, s1, e));
		ctx.doSpline(handDrawnLine(s1, end, e), true);
		ctx.doSpline(handDrawnLine(end, c, e), true);
		ctx.fillStyle = "black";
		ctx.fill();
		ctx.beginPath();
		ctx.doSpline(handDrawnLine(c, s2, e));
		ctx.doSpline(handDrawnLine(s2, end, e), true);
		ctx.doSpline(handDrawnLine(end, c, e), true);
		ctx.fillStyle = "red";
		ctx.fill();
	}
	compassPoint(1 * PI / 4);
	compassPoint(3 * PI / 4);
	compassPoint(5 * PI / 4);
	compassPoint(7 * PI / 4);
	compassPoint(0 * PI / 2);
	compassPoint(1 * PI / 2);
	compassPoint(2 * PI / 2);
	compassPoint(3 * PI / 2);
}


function quasiRandomPointCloud(count, x, y, w, h) {
	function randomMostDistantPoint(n, pts) {
		var result;
		var farness = 0;
		for (var i = 0; i < n; ++i) {
			var c = { x: x + rand() * w, y: y + rand() * h };
			var d = minDistance(c, pts);
			if (i == 0 || farness < d) {
				farness = d;
				result = c;
			}
		}
		return result;
	}

	var pts = [];
	for (var i = 0; i < count; i++)
		pts.push(randomMostDistantPoint(1 + i/100, pts));
	return pts;
}

CanvasRenderingContext2D.prototype.forest = function (x, y, w, h) {
	var ctx = this;
	var R = 10;
	var pts = quasiRandomPointCloud(w * h / (R * R * PI/2), x, y, w, h);
	pts = pts.sort(function (a,b) { return a.y - b.y });
	ctx.fillStyle = "white";
	pts.forEach(function (p) {
		ctx.beginPath();
		ctx.doSpline(handDrawnLine(p, add(p, {x:0, y:R*1.3})));
		ctx.stroke();
		ctx.beginPath();
		ctx.doSpline(handDrawnArc(p, R, -PI/2, 3*PI/2));
		ctx.fill();
		ctx.stroke();
	});
}

function dump(label, arr) {
	for (var i = 0; i < arr.length; ++i) console.log(label, i, arr[i]);
}

Array.prototype.has = function (e) { return this.indexOf(e) >= 0 };

CanvasRenderingContext2D.prototype.network = function (x, y, w, h) {
	var ctx = this;
	var R = 20;
	var N = w * h / (R * R * PI/2);
	var pts = quasiRandomPointCloud(N, x, y, w, h);
	var voi = new Triangulation(pts);

	// Trace in a mountain range
	var active = [pick(voi.seeds.length)];
	for (var i = 0; i < 30; ++i) {
		active.map(function(a) { voi.seeds[a].terrain = 'mountain' });
		var ns = active.reduce(function (p, c) { return p.concat(voi.seeds[c].neighbors) }, []);
		ns = Array.from(new Set(ns)).filter(function (n) { return !voi.seeds[n].terrain });
		if (ns.length == 0) break;
		active = [pick(ns)];
		for (var k = 0; k < 1; ++k) {
			var eligible = ns.filter(function (n) {
				return !active.has(n) && voi.seeds[active[0]].neighbors.has(n)
			});
			if (eligible.length == 0) break;
			active.push(pick(eligible));
		}
		ns.map(function (n) { voi.seeds[n].terrain = 'foothill' });
	}

	var SHOWALL = true;

	ctx.strokeStyle = "#fee";
	if (SHOWALL) voi.triangles.forEach(function (t) {
		ctx.beginPath();
		ctx.moveTo(pts[t.p1].x, pts[t.p1].y);
		ctx.lineTo(pts[t.p2].x, pts[t.p2].y);
		ctx.lineTo(pts[t.p3].x, pts[t.p3].y);
		ctx.lineTo(pts[t.p1].x, pts[t.p1].y);
		// ctx.fillStyle = "#"+(Math.random()*0xFFFFFF<<0).toString(16);
		// ctx.fill();
		ctx.stroke();
	});

	ctx.strokeStyle = "#afa";
	if (SHOWALL) voi.edges.forEach(function (e) {
		ctx.beginPath();
		ctx.moveTo(voi.nodes[e.p1].x, voi.nodes[e.p1].y);
		ctx.lineTo(voi.nodes[e.p2].x, voi.nodes[e.p2].y);
		ctx.stroke();
	});
	ctx.strokeStyle = "#000";

	if (SHOWALL) voi.seeds.forEach(function (p) {
		if (p.terrain == 'mountain')
			ctx.fillStyle = '#080';
		else if (p.terrain == 'foothill')
			ctx.fillStyle = '#8f8';
		else
			ctx.fillStyle = "pink";
		ctx.fillRect(p.x, p.y, 6, 6);
	});

	ctx.fillStyle = "#00f";
	if (SHOWALL) voi.nodes.forEach(function (p) {
		ctx.fillRect(p.x, p.y, 2, 2);
	});

	// Find coastline endpoints
	var tl = 0, dtl = Number.POSITIVE_INFINITY;
	var br = voi.nodes.length - 1, dbr = Number.POSITIVE_INFINITY;
	for (var i = 0; i < voi.nodes.length; ++i) {
		var vi = voi.nodes[i];
		if (vi.y <= 0 && abs(vi.x - W/8) < dtl) {
			tl = i;
			dtl = abs(vi.x - W/8);
		}
		if (vi.y >= H && abs(vi.x - W/2) < dbr) {
			br = i;
			dbr = abs(vi.x - W/2);
		}
	}
	var coastline = voi.findPath(tl, br,
		function (i) {
			var es = voi.nodes[i].edges;
			var result = new Set();
			for (var j = 0; j < es.length; ++j) {
				var e = voi.edges[es[j]];
				result.add(i == e.p1 ? e.p2 : e.p1);
			}
			return result;
		},
		function (i,j) {
			var d = distance(voi.nodes[i], voi.nodes[j]);
			d += 6000 / distance(voi.nodes[i], {x:W/3,y:H/4});
			d += 6000 / distance(voi.nodes[i], {x:W/3,y:H/4});
			d += 3000 / distance(voi.nodes[j], {x:W/3,y:H});
			d += 3000 / distance(voi.nodes[j], {x:W/3,y:H});
			return d;
		});

	ctx.doSpline(coastline.map(p => voi.nodes[p]));
	ctx.strokeStyle = "#000";
	ctx.stroke();
}

function meander(p, n, d, a) {
	var result = [copy(p)];
	for (var i = 1; i <= n; ++i) {
		a += crand(2) * crand(3);
		p = add(p, p2c(d/n, a));
		result.push(p);
	}
	return result;
}

function drawMap() {
	var ctx = canvas.getContext("2d");
	ctx.save();
	ctx.clearRect(0,0,canvas.width, canvas.height);
	ctx.lineWidth = 1;
	ctx.strokeStyle = "#000";
	ctx.drawBorder(10);
	ctx.drawBorder(15);
	ctx.clip();

	// Draw compass rose in the corner
	var R = 45;
	ctx.compassRose(W - 2 * R, 2 * R, R);

	// Size of a single mountain
	var DW = 20, DH = DW;

	// Fill the world with mountains
	//ctx.fieldOfMountains(DW, DH);

	// Get a closer look at one mountain
	// bigOneInMiddle(ctx, DW, DH);

	// Run chains of mountains
	//for (var i = 0; i < 4; i++) ctx.mountainRange(DW, DH);

	// Plant a forest
	//ctx.forest(100, 100, 200, 300);

	// Test of random spline making
	// for (var i = 0; i < 100; ++i)
	//  	ctx.doSpline(meander({x:W/2, y:0}, 10, H * 1.25, PI/2));
	// ctx.stroke();

	// Test of voronoi tiling generation
	ctx.network(0, 0, W, H);

	// Noise function is here for future use depending on how map gen is going to work in the long run
	// It isn't used now
	// let noise = Noise(20);
	// noise.show(canvas.getContext("2d"));

}

function Noise(scale) {
	// Midpoint displacement noise.
	// The generated noise is scaled down in res
	var scaledW = ceil(W / scale);
	var scaledH = ceil(H / scale);
	var points = new Float32Array(scaledW * scaledH);
	function pt(x, y, v) { // get or set a value in the 2d array
		var i = scaledW * y + x;
		if (typeof v != 'undefined') {
			points[i] = v;
		} else if (x < 0) {
			return 0;
		} else if (x >= scaledW) {
			return 1;
		} else if (y < 0 || y >= scaledH) {
			return x / scaledW;
		} else {
			return points[i];
		}
	}

	function bishopavg(x, y, d) {
	return (pt(x-d,y-d) + pt(x+d,y-d) +
	        pt(x-d,y+d) + pt(x+d,y+d)) / 4;
	}

	function rookavg(x, y, d) {
	return (      pt(x,y-d) +
	        pt(x-d,y) + pt(x+d,y) +
	              pt(x,y+d)) / 4;
	}

	var persistence = 1/2;
	var SQRT2 = sqrt(2);

	// Find largest power of 2 smaller than either dimension
    var n = 1;
    while (2*n < scaledW && 2*n < scaledH) n *= 2;

    // Fill in initial values along top and left edges
    for (var y = 0; y < scaledH; ++y) pt(0, y, 0);
    for (var x = 0; x < scaledW; ++x) pt(x, 0, pt(x, -1));

    // At each scale level, apply diamond-square algorithm to
    // midpoints between existing values
    var sigma = pt(n, 0);
    while (n > 0) {
      for (var y = n; y < scaledH; y += 2*n) {
        for (var x = n; x < scaledW; x += 2*n) {
          pt(x, y, crand(2 * sigma) * SQRT2 + bishopavg(x,y,n));
        }
      }

      for (var y = 0; y < scaledH; y += 2*n) {
        for (var x = n; x < scaledW; x += 2*n) {
          pt(x, y, crand(2 * sigma) + rookavg(x,y,n));
        }
      }

      for (var y = n; y < scaledH; y += 2*n) {
        for (var x = 0; x < scaledW; x += 2*n) {
          pt(x, y, crand(2 * sigma) + rookavg(x,y,n));
        }
      }

      n >>= 1;
      sigma *= persistence;
  	}

	var result = function (x, y) {
		return pt(x / scale >> 0, y / scale >> 0);
	}

  	// Draw what we've generated
  	function rgb(r,g,b) { return "rgb(" + (r * 255 >> 0) + "," + (g * 255 >> 0) + "," + (b * 255 >> 0) + ")" }
  	result.show = function (ctx) {
	  	for (var y = 0; y < scaledH; ++y) {
	  		for (var x = 0; x < scaledW; ++x) {
	  			ctx.fillStyle = rgb(pt(x,y),pt(x,y),pt(x,y));
	  			ctx.fillRect(x * scale, y * scale, scale, scale);
	  		}
	  	}
  	}

	return result;
}




canvas.addEventListener("click", drawMap);
window.addEventListener("load", drawMap);
// drawMap();

</script>
</body>
</html>